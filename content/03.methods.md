## Methods

### Indexing paths in GAF files

The sorting and indexing algorithm is most efficient and makes sense when node IDs are integer sorted based on the topology of the pangenome graph.
This is the case for pangenomes constructed by minigraph-cactus[@minigraph_cactus], PGGB[@pggb], or `vg construct`[@vg].
Otherwise, the pangenome graph can be *sorted*, i.e. changing the node IDs, using `vg` or `odgi`[@odgi].
If the node IDs are sorted integers, a short path through the graph should only traverse nodes with IDs contained in a small interval.
The main approach of the GAF sorting and indexing approach is to work with those intervals.
Hence, to sort a GAF file, each path is first parsed to extract the minimum and maximum node IDs.
The paths are then sorted first by their minimum ID, and then by their maximum ID. 
This is similar to the approach used to sort BED or VCF files on linear genomes: they are sorted by sequence name, then start position, then end position.

A GAF sorting feature has been added to the `vg` toolkit, within the `gamsort` subcommand.
It first sorts chunks of GAF records (e.g. reads), to avoid having to hold the entire set in memory.
The sorted chunks are then merged into the final sorted GAF file.
This GAF sorting implementation was included in `vg` in version 1.56.
A sorted GAF file can be compressed in the BGZF format using `bgzip`.
The BGZF format is an implementation of the standard gzip format that compresses a file by block to facilitate their random access.
It is used to compress among others, VCF, BED, or BAM files with HTSlib[@htslib].

HTSlib[@htslib] was then modified to index bgzipped GAF files.
Similar to other tab-separated file like VCF or BED, a *gaf* preset was added to `tabix`.
For BED or VCF, `tabix` extract the interval information from the columns with the sequence names and genomic position[@tabix]. 
In the new *gaf* preset, it instead parses the path information in the GAF file to extract the minimum and maximum node IDs.
The indexing is then based on this interval, the same as used for the sorting described above.

We tested the GAF sorting and indexing performance on 30X coverage Illumina short reads from HG002.
The reads were downloaded from `https://s3-us-west-2.amazonaws.com/human-pangenomics/NHGRI_UCSC_panel/HG002/hpp_HG002_NA24385_son_v1/ILMN/downsampled/`.
We mapped them using giraffe[@giraffe] on a personnalized pangenome[@hapsamp] from the HPRC v1.1 Minigraph-Cactus pangenome.
The reads were outputted in GAM first to compare the file size and sorting runtimes.
The GAM file was sorted with `vg gamsort`.
It was then converted to a GAF file using `vg convert` and sorted using `vg gamsort` with the new GAF sorting mode described above.
We compared the file sizes and sorting runtimes between both approach.
The query time was also measured on ten thousand regions of the pangenome defined as node ranges. 
Those node ranges were defined by picking a random starting node position the reference path and walking 50 steps along that path.
The commands and details for this benchmarking is available in the `analysis/readsorting` folder of this paper's repository[@repo].

### Querying GAF files

Instead of indexing on a sequence name and genomic position, we can query on a node interval.
In HTSlib, `tabix` was modified to disregard the sequence name when querying intervals for a GAF file. 
The interval is defined by the values typically used for the *start* and *end* position of genomic coordinates.

Commands to query slices of the pangenome in `vg` were also updated.
The `find` and `chunk` subcommands use the updated HTSlib library to extract the appropriate paths from the nodes selected.
Internally, those commands identify a first subgraph, for example corresponding to a genomic interval on the reference path provided by the user. 
This subgraph is then extended with more *context* to include non-reference regions of the graph.
The amount of context is also controlled by the user.
Finally, the subgraph or the paths (usually reads) overlapping these nodes are extracted.
This last step was updated to be able to extract paths in an indexed GAF file using HTSlib.
As for sorted GAM files, it is now possible to extract a slice of a indexed GAF file based on node intervals, coordinates on a reference path, multiple coordinates in a BED file, a provided subgraph (see User Guide at ??).

### Projecting annotations onto a pangenome

A pangenome represents multiple genomes for which annotations might be available. 
We describe an approach to project annotations relative to a genome onto a pangenome.
We recently updated the `annotate` subcommand from the `vg` toolkit to project regions represented in the BED or GFF files onto the latest pangenomes from the HPRC.
Currently, the genome to annotate must be a *reference* path in the pangenome. 
The `gbwt` subcommand can making a  specific path into a *reference* path in about ?? minutes.
Once a genome or haplotype is a *reference* path, a pangenome can be queried using coordinates on this path.
Internally, `vg annotate` looks for the location of a path in pangenome graph for each input region.
The path, represented as an *alignment* record, is then written either in GAM or GAF formats.
Of note, a path can be broken in multiple disjointed parts.
It happens in the recent human draft pangenome when some regions are clipped out, for example across centromeres or when creating suspiciously large structural variants.
Projected annotations are hence also broken up if needed when they overlap with breakpoints.
The name of the annotated path in the output GAF is picked from the BED file's 4th column, or the *Name* and *ID* GFF field.

We test this approach by projecting the gene annotation, repeat annotations, and segmental duplication annotation for each of the 88 assembled haplotypes in the draft human pangenome from the HPRC (v1.1).
The gene annotations from CAT[@doi:10.1101/gr.233460.117] (GFF files) were downloaded from ??.
The repeat annotations from RepeatMasker (BED files) were downloaded from ??.
The predicted segmental duplications from ?? (BED files) were downloaded from ??.
A helper script was implemented to prepare the BED files with informative names.
For example, for repeats from the RepeatMasker annotation, we name each element by their repeat class and repeat family.
The projection of those annotations for each haplotype was automated with a Snakemake workflow available in the `analysis/annotate` folder of this paper's repository[@repo].

### Coverage track from mapped reads

Functional genomics datasets are often visualized as a coverage track.
High coverage in a region might suggest a strong transcription factor binding site or regulatory region. 

We implemented an approach to summarize the coverage of reads across the pangenome into paths with similar coverage. 
The coverage in every node is first binned into a few coverage classes, for example representing low, medium and high coverage. 
By default we use 1, 5, and 30 reads as coverage breakpoints to save three bins: 1-5, 5-30, 30+. 
Regions with no coverage are not saved.
Once the coverage is binned, we extend greedily to connected nodes and bins if in the same coverage class.
This extension step produces path through the pangenome with consistent coverage. 
The paths are written in the GAF format, recording the coverage class and the average coverage across the path.

`cartoon to explain this in supplement?`{.red}

This algorithm was implemented in Python and uses the *libbdsg* module[@libbdsg] to query the pangenome.
It is made available in the public repository of this study in the `analysis/encode` folder of this paper's repository[@repo].

### Annotating known variants

Variants from public databases were annotated when matching a variant site in the pangenome. 
We implemented an approach to look for input variants in the pangenome and write a GAF file with the path followed by those variants in the pangenome. 
The variants are matched with the VCF representation of the HPRC Minigraph-Cactus v1.1 pangenome, produced by running `vg deconstruct` on the pangenome file.
This VCF file contains the all variants and their paths through the pangenome in the *AT* *INFO* field.
We look for the variants of interest in this VCF and extract the appropriate path using the *AT* field.
The annotation path follows either the alternate allele of the variant if known and present in the pangenome, or the reference allele path if the alternate allele is unknown but there is a variant at this position in the pangenome.
Variant that are not matched in the pangenome are skipped.
This algorithm was implemented in Python and uses the *libbdsg* module[@libbdsg] internally to get node size information necessary to write proper GAF records.

We test this approach on the GWAS catalog[@doi:10.1093/nar/gkac1010] and GTEX expression QTLs[@doi:10.1038/ng.2653].
The GWAS catalog was downloaded from the UCSC Genome Browser `gwasCatalog` table[@doi:10.1093/nar/gkac1072 ].
The eQTLs from GTEX v8 were downloaded from `https://storage.googleapis.com/adult-gtex/bulk-qtl/v8/single-tissue-cis-qtl/GTEx_Analysis_v8_eQTL.tar`.
The files defining associations between variant/gene pairs were parsed for each tissue.
As before, the output annotation in GAF were bgzipped, sorted and indexed.

We implemented another, more straightforward approach, to annotate variants that were genotyped using the pangenome.
Here we simply convert a VCF that contain allele traversal information (*AT* field) to a GAF file representing the alternate allele.
We test this approach by genotyping HG002 from short-reads Illumina Novaseq data. `more details`{.red}

The scripts and pipeline to annotate variants is available in the public repository of this study in the `analysis/variants` folder of this paper's repository[@repo].

### Visualization in the sequenceTubeMap

The sequenceTubeMap was develop to interactively explore a pangenome graph, haplotypes traversing it, and reads mapping to it[@tubemap]. 
It internally calls *vg* to extract the relevant slice of the pangenome graph and reads. 
To extract reads, it was only accepting GAM file that had been sorted and indexed *vg*.
We have updated it to accept GAF files that have been sorted, compressed and indexed as explained above.

The new version of the sequenceTubeMap can also display multiple layers of haplotypes or reads. 
As *reads*, the user can now add layers of annotations represented and prepared as indexed GAF files.
A different color or color palette can be assigned to each layer to facilitate the visualization of different datasets in the same local pangenome region. 
For example, one could visualize the coding regions of genes and coverage tracks for different cell types from the ENCODE project (Fig ??).

### Visualization in Bandage

A fork of Bandage[@bandage], called BandageNG[@{https://github.com/asl/BandageNG}], can visualize paths of the input graph by coloring the nodes.
We implemented a wrapper script to facilitate the preprocessing of a subgraph to visualize with BandageNG. 
It starts by extracting the subgraph of a full pangenome for a region of interest.
It also extract annotations from indexed files on that same region. 
The annotated paths are then added to the subgraph using `vg augment`. 
The new pangenome subgraph is converted to GFA and contains both the original paths (e.g. haplotypes) and the newly integrated annotations (e.g. gene location, repeats).
The output of this script can be opened with BandageNG for interactive exploration. 
In particular, the *Path search* feature can find nodes corresponding to specific paths, which are either haplotypes or annotations in this pre-processed GFA file.
The user can select a *path*, color the nodes and label the path `check/update`{.red}.
The helper script and a tutorial are available at the `analysis/??`{.red} folder of this paper's repository[@repo].

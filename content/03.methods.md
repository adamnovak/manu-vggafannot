## Methods

### Indexing paths in GAF files

The sorting and indexing algorithm is most efficient and makes sense when node IDs are integer sorted based on the topology of the pangenome graph.
This is the case for pangenomes constructed by minigraph-cactus[@minigraph_cactus], PGGB[@pggb], or `vg construct`[@vg].
Otherwise, the pangenome graph can be *sorted*, i.e. changing the node IDs, using `vg` or `odgi`[@odgi].
If the node IDs are sorted integers, a short path through the graph should only traverse nodes with IDs contained in a small interval (see Figure {@fig:index}A).
The main approach of the GAF sorting and indexing approach is to work with those intervals.
Hence, to sort a GAF file, each path is first parsed to extract the minimum and maximum node IDs (see Figure {@fig:index}B).
The paths are then sorted first by their minimum ID, and then by their maximum ID. 
This is similar to the approach used to sort BED or VCF files on linear genomes: they are sorted by sequence name, then start position, then end position.

![
**Path sorting and indexing using vg and HTSlib/tabix**
**A.** A region of pangenome is represented with nodes (containing sequences) in yellow and edges in black. 
The node IDs are topologically sorted integers, ranging here from 23 to 36.
Three paths are highlighted in red, blue and green. 
**B.** The three paths are written with the GAF syntax, by specifying the orientations (`<`/`>`) and IDs of the traversed nodes.
For each path, the node range *n-N*, between the minimum and maximum node IDs, is used for sorting the path.
**C.** Overview of the workflow to sort a GAF file using `vg gamsort`, compress it with `bgzip` and index using `tabix`. 
**D.** The small *.tbi* index file helps query slices of the GAF file quickly. For example using `tabix`, or `vg` subcommands like `find` or `chunk`.
](figures/gafindexing.png "GAF indexing"){#fig:index}

A GAF sorting feature has been added to the `vg` toolkit, within the `gamsort` subcommand  (see Figure {@fig:index}C).
It first sorts chunks of GAF records (e.g. reads), to avoid having to hold the entire set in memory.
The sorted chunks are then merged into the final sorted GAF file.
This GAF sorting implementation was introduced in `vg` version 1.56.
A sorted GAF file can be compressed in the BGZF format using `bgzip`.
The BGZF format is an implementation of the standard gzip format that compresses a file by block to facilitate their random access.
It is used to compress among others, VCF, BED, or BAM files with HTSlib[@htslib].

HTSlib[@htslib] was then modified to index bgzipped GAF files.
Similar to other tab-separated file like VCF or BED, a *gaf* preset was added to `tabix`.
For BED or VCF, `tabix` extract the interval information from the columns with the sequence names and genomic position[@tabix]. 
In the new *gaf* preset, it instead parses the path information in the GAF file to extract the minimum and maximum node IDs.
The indexing is then based on this interval, the same as used for the sorting described above.

We tested the GAF sorting and indexing performance on 30X coverage Illumina short reads from HG002.
The reads were downloaded from `https://s3-us-west-2.amazonaws.com/human-pangenomics/NHGRI_UCSC_panel/HG002/hpp_HG002_NA24385_son_v1/ILMN/downsampled/`.
We mapped them using giraffe[@giraffe] on a personnalized pangenome[@hapsamp] from the HPRC v1.1 Minigraph-Cactus pangenome.
The reads were outputted in GAM first to compare the file size and sorting runtimes.
The GAM file was sorted with `vg gamsort`.
It was then converted to a GAF file using `vg convert` and sorted using `vg gamsort` with the new GAF sorting mode described above.
We compared the file sizes and sorting runtimes between both approach.
The query time was also measured on ten thousand regions of the pangenome defined as node ranges. 
Those node ranges were defined by picking a random starting node position the reference path and walking 50 steps along that path.
The commands and details for this benchmarking is available in the `analysis/readsorting` folder of this paper's repository[@repo].

### Querying GAF files

Instead of indexing on a sequence name and genomic position, we can query on a node interval (see Figure {@fig:index}D).
In HTSlib, `tabix` was modified to disregard the sequence name when querying intervals for a GAF file. 
The interval is defined by the values typically used for the *start* and *end* position of genomic coordinates.

Commands to query slices of the pangenome in `vg` were also updated.
The `find` and `chunk` sub-commands use the updated HTSlib library to extract the appropriate paths from the nodes selected.
Internally, those commands identify a first subgraph, for example corresponding to a genomic interval on the reference path provided by the user. 
This subgraph is then extended with more *context* to include non-reference regions of the graph.
The amount of context is also controlled by the user.
Finally, the subgraph or the paths (usually reads) overlapping these nodes are extracted.
This last step was updated to be able to extract paths in an indexed GAF file using HTSlib.
As for sorted GAM files, it is now possible to extract a slice of a indexed GAF file based on node intervals, coordinates on a reference path, multiple coordinates in a BED file, a provided subgraph (see User Guide in the `analysis` folder of this paper's repository[@repo]).

### Projecting annotations onto a pangenome

A pangenome represents multiple genomes for which annotations might be available. 
We describe an approach to project annotations relative to a genome into a pangenome.
We recently updated the `annotate` subcommand from the `vg` toolkit to project regions represented in the BED or GFF files into the latest pangenomes from the HPRC.
Currently, the genome to annotate must be a *reference* path in the pangenome, but any path can be set as reference using the `vg gbwt` subcommand (~1 minute).
Then, `vg annotate` looks for the location of a path in pangenome graph for each input region.
The path, represented as an *alignment* record, is then written either in GAM or GAF formats.
Of note, a path can be broken in multiple disjointed parts.
It happens in the recent human draft pangenome when some regions are clipped out, for example across centromeres or when creating suspiciously large structural variants.
Projected annotations are hence also broken up if needed when they overlap with breakpoints.
The name of the annotated path in the output GAF is picked from the BED file's 4th column, or the *Name* and *ID* GFF fields.

We test this approach by projecting the gene annotation, repeat annotations, and segmental duplication annotation for each of the 88 assembled haplotypes into the draft human pangenome from the HPRC (v1.1).
These annotations were downloaded from the HPRC public repository at `https://raw.githubusercontent.com/human-pangenomics/HPP_Year1_Assemblies/main/annotation_index/`.
The gene annotations from CAT[@doi:10.1101/gr.233460.117] (GFF files) were downloaded using the URLs in the `Year1_assemblies_v2_genbank_CAT_genes.index` file, the repeat annotations from RepeatMasker (BED files)  from `Year1_assemblies_v2_genbank_Repeat_Masker.index`, segmental duplications (BED files) from `Year1_assemblies_v2_genbank_Seg_Dups.index`, and simple repeats from `Year1_assemblies_v2_genbank_TRF.index`.
A helper script was implemented to prepare the BED files with informative names.
For example, for repeats from the RepeatMasker annotation, we name each element by their repeat class and repeat family.
The projection of those annotations for each haplotype into the pangenome was automated with a Snakemake workflow available in the `analysis/annotate` folder of this paper's repository[@repo].

### Coverage track from mapped reads

Functional genomics datasets are often visualized as a coverage track.
High coverage in a region might suggest a strong transcription factor binding site or regulatory region. 

We implemented an approach to summarize the coverage of reads across the pangenome into paths with similar coverage (see Figure @fig:meth_cov). 
The coverage in every node is first binned into a few coverage classes, for example representing low, medium and high coverage. 
By default we use 1, 5, and 30 reads as coverage breakpoints to save three bins: 1-5, 5-30, 30+. 
Regions with no coverage are not saved.
Once the coverage is binned, we extend greedily to connected nodes and bins if in the same coverage class.
This extension step produces path through the pangenome with consistent coverage. 
The paths are written in the GAF format, recording the coverage class and the average coverage across the path.

![
**Read coverage bin-and-extend approach to produce coarse-grained coverage tracks**
In each node (*grey rectangles*), the read coverage is first binned using user-defined coverage bins (*red blocks*).
Each bin is then extended, one at a time (*green flags*), until reaching a different coverage bin (*red flag*).
](figures/coverage.bin.pangenome.png "Method to make a coverage track from mapped reads"){#fig:meth_cov}

This algorithm was implemented in Python and uses the *libbdsg* module[@libbdsg] to query the pangenome.
It is made available in the public repository of this study in the `analysis/encode` folder of this paper's repository[@repo].

We tested this approach on ATAC-seq datasets from ENCODE[@encode;@encode_portal] on seven tissues: breast epithelium (*ENCFF210QPG*), gastrocnemius medialis (*ENCFF968KAQ*), gastroesophageal sphincter (*ENCFF553SEZ*), Peyer's patch (*ENCFF272PIN*), sigmoid colon (*ENCFF775DFR*), spleen (*ENCFF391IHY*), thyroid gland (*ENCFF579WLS*).
Paired-end short Illumina HiSeq 4000 reads were downloaded from ENCODE and mapped using giraffe[@giraffe] on the HPRC v1.1 Minigraph-Cactus pangenome.
The output to `vg pack` (with `-Q 1` to keep reads with mapping quality of at least 1) was piped to the script implementing the coverage track computation described above.

### Annotating known variants

Variants from public databases were annotated when matching a variant site in the pangenome. 
We implemented an approach to look for input variants in the pangenome and write a GAF file with the path followed by those variants in the pangenome. 
The variants are matched with the VCF representation of the HPRC Minigraph-Cactus v1.1 pangenome, produced by running `vg deconstruct` on the pangenome file.
This VCF file contains the all variants and their paths through the pangenome in the *AT* *INFO* field.
We look for the variants of interest in this VCF and extract the appropriate path using the *AT* field.
The annotation path follows either the alternate allele of the variant if known and present in the pangenome, or the reference allele path if the alternate allele is unknown but there is a variant at this position in the pangenome.
Variant that are not matched in the pangenome are skipped.
This algorithm was implemented in Python and uses the *libbdsg* module[@libbdsg] internally to get node size information necessary to write proper GAF records.

We test this approach on the GWAS catalog[@doi:10.1093/nar/gkac1010] and GTEX expression QTLs[@doi:10.1038/ng.2653].
The GWAS catalog was downloaded from the UCSC Genome Browser `gwasCatalog` table[@doi:10.1093/nar/gkac1072 ].
The eQTLs from GTEX v8 were downloaded from `https://storage.googleapis.com/adult-gtex/bulk-qtl/v8/single-tissue-cis-qtl/GTEx_Analysis_v8_eQTL.tar`.
The files defining associations between variant/gene pairs were parsed for each tissue.
As before, the output annotation in GAF were bgzipped, sorted and indexed.

We implemented another, more straightforward approach, to annotate variants that were genotyped using the pangenome.
Here we simply convert a VCF that contain allele traversal information (*AT* field) to a GAF file representing the alternate allele.
We test this approach by genotyping HG002 from the short-reads Illumina Novaseq reads aligned to the pangenome for the GAF sorting experiment (more details above).
Variants were genotyped from the aligned reads using `vg call`.
Of note, `vg call` can also output genotypes directly in GAF format with the `-G` parameter.

The scripts and pipeline to annotate variants is available in the public repository of this study in the `analysis/variants` folder of this paper's repository[@repo].

### Visualization in the Sequence Tube Map

The Sequence Tube Map was developed to interactively explore a pangenome graph, haplotypes traversing it, and reads mapping to it[@tubemap]. 
It internally calls *vg* to extract the relevant slice of the pangenome graph and reads. 
Only accepting reads in the GAM format, sorted and indexed *vg*, were originally accepted.
We updated the Sequence Tube Map to accept GAF files that have been sorted, compressed and indexed as explained above.

The new version of the Sequence Tube Map can also display multiple layers of haplotypes or reads. 
As *reads*, the user can now add layers of annotations written indexed GAF files.
A different color or color palette can be assigned to each layer to facilitate the visualization of different datasets in the same local pangenome region. 
Moreover, a new option has been added to use an element's opacity to represent an integer score, like a mapping quality or read coverage.
For example, one could visualize the coding regions of genes and coverage tracks for different cell types from the ENCODE project, as described below and highlighted in Figure @fig:tubemap.

### Visualization in Bandage

Bandage-NG[@{https://github.com/asl/BandageNG}], a tool derived from Bandage[@bandage], can read GAF files and visualize its paths through the input graph by coloring the nodes.
Of note, the offset positions are not taken into account, which means that nodes are colored entirely even if the path only overlaps part of it.
We implemented a wrapper script to facilitate the preprocessing of a subgraph to visualize with Bandage-NG. 
It starts by extracting the subgraph of a full pangenome for a region of interest using `vg chunk`.
This graph is converted to GFA, making sure that the path are written last.
The script also extracts annotations from indexed files on that same region. 
Those GAF files are merged and modified if necessary: path names are de-duplicated and paths are trimmed when traversing nodes absent from the extracted subgraph.
These modifications ensure that the final GAF file can be loaded in Bandage-NG.
The outputs of this script can be opened with Bandage-NG for interactive exploration. 
In particular, the *Find path* feature can find nodes corresponding to specific paths, which are either haplotypes or annotations in this pre-processed GFA file.
The user can select a *path* and color its nodes.
The helper script and a tutorial are available at the `analysis/visualization` folder of this paper's repository[@repo].
